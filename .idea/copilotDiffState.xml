<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Paint/Paint/src/paint/controller/FXMLDocumentController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Paint/Paint/src/paint/controller/FXMLDocumentController.java" />
              <option name="originalContent" value="package paint.controller;&#10;&#10;&#10;import java.io.IOException;&#10;import java.net.URL;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.ResourceBundle;&#10;import java.util.Stack;&#10;import java.util.logging.Level;&#10;import java.util.logging.Logger;&#10;import javafx.collections.FXCollections;&#10;import javafx.collections.ObservableList;&#10;import javafx.event.ActionEvent;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.Initializable;&#10;import javafx.geometry.Point2D;&#10;import javafx.scene.control.Button;&#10;import javafx.scene.control.ColorPicker;&#10;import javafx.scene.control.ComboBox;&#10;import javafx.scene.layout.GridPane;&#10;import javafx.scene.layout.Pane;&#10;import javafx.scene.canvas.*;&#10;import javafx.scene.control.Label;&#10;import javafx.scene.control.ListView;&#10;import javafx.scene.control.TextField;&#10;import javafx.scene.input.MouseEvent;&#10;import javafx.scene.paint.*;&#10;import javax.xml.parsers.ParserConfigurationException;&#10;import org.xml.sax.SAXException;&#10;import paint.model.*;&#10;&#10;&#10;public class FXMLDocumentController implements Initializable, DrawingEngine {&#10;  &#10;    /***FXML VARIABLES***/&#10;    @FXML&#10;    private Button DeleteBtn;&#10;&#10;    @FXML&#10;    private ComboBox&lt;String&gt; ShapeBox;&#10;&#10;    @FXML&#10;    private Button UndoBtn;&#10;&#10;    @FXML&#10;    private Button RedoBtn;&#10;&#10;    @FXML&#10;    private ColorPicker ColorBox;&#10;&#10;    @FXML&#10;    private Button SaveBtn;&#10;    &#10;    @FXML&#10;    private Button MoveBtn;&#10;    &#10;    @FXML&#10;    private Button RecolorBtn;&#10;    &#10;    @FXML&#10;    private Button LoadBtn;&#10;    &#10;    @FXML&#10;    private GridPane After;&#10;    &#10;    @FXML&#10;    private Pane Before;&#10;    &#10;    @FXML&#10;    private Pane PathPane;&#10;    &#10;    @FXML&#10;    private TextField PathText;&#10;&#10;    @FXML&#10;    private Button StartBtn;&#10;    &#10;    @FXML&#10;    private Button ResizeBtn;&#10;    &#10;    @FXML&#10;    private Button ImportBtn;&#10;    &#10;    @FXML&#10;    private Button PathBtn;&#10;    &#10;    @FXML&#10;    private Canvas CanvasBox;&#10;    &#10;    @FXML&#10;    private Button CopyBtn;&#10;    &#10;    @FXML&#10;    private Button GroupBtn;&#10;&#10;    @FXML&#10;    private Button UngroupBtn;&#10;&#10;    @FXML&#10;    private Label Message;&#10;    &#10;    @FXML&#10;    private ListView ShapeList;&#10;    &#10;    &#10;    &#10;    /***CLASS VARIABLES***/&#10;    private Point2D start;&#10;    private Point2D end;&#10;    &#10;    //SINGLETON DP&#10;    private static ArrayList&lt;Shape&gt; shapeList = new ArrayList&lt;&gt;();&#10;    &#10;    private boolean move=false;&#10;    private boolean copy=false;&#10;    private boolean resize=false;&#10;    private boolean save=false;&#10;    private boolean load=false;&#10;    private boolean importt =false;&#10;    &#10;    //MEMENTO DP&#10;    private Stack&lt;ArrayList&lt;Shape&gt;&gt; primary = new Stack&lt;&gt;();&#10;    private Stack&lt;ArrayList&lt;Shape&gt;&gt; secondary = new Stack&lt;&gt;();&#10;&#10;&#10;    &#10;    @FXML&#10;    private void handleButtonAction(ActionEvent event) {&#10;        if(event.getSource() == StartBtn){&#10;            Before.setVisible(false);&#10;            After.setVisible(true);&#10;        }&#10;        &#10;        Message.setText(&quot;&quot;);&#10;        if(event.getSource()==DeleteBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;            int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;            removeShape(shapeList.get(index));&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to delete it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==RecolorBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;                int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;                shapeList.get(index).setFillColor(ColorBox.getValue());&#10;                refresh(CanvasBox);&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to recolor it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==MoveBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;                move=true;&#10;                Message.setText(&quot;Click on the new top-left position below to move the selected shape.&quot;);&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to move it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==CopyBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;                copy=true;&#10;                Message.setText(&quot;Click on the new top-left position below to copy the selected shape.&quot;);&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to copy it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==ResizeBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;                resize=true;&#10;                Message.setText(&quot;Click on the new right-button position below to resize the selected shape.&quot;);&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to copy it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==UndoBtn){&#10;            if(primary.empty()){Message.setText(&quot;We are back to zero point! .. Can Undo nothing more!&quot;);return;}&#10;            undo();&#10;        }&#10;        &#10;        if(event.getSource()==RedoBtn){&#10;            if(secondary.empty()){Message.setText(&quot;There is no more history for me to get .. Go search history books.&quot;);return;}&#10;            redo();&#10;        }&#10;        &#10;        if(event.getSource()==SaveBtn){&#10;            showPathPane();&#10;            save=true;&#10;        }&#10;        &#10;        if(event.getSource()==LoadBtn){&#10;            showPathPane();&#10;            load=true;&#10;        }&#10;        &#10;        if(event.getSource()==ImportBtn){&#10;            showPathPane();&#10;            importt=true;&#10;        }&#10;        &#10;        if(event.getSource()==PathBtn){&#10;            if(PathText.getText().isEmpty()){PathText.setText(&quot;You need to set the path of the file.&quot;);return;}&#10;            if(save){save=false;save(PathText.getText());}&#10;            else if(load){load=false;load(PathText.getText());}&#10;            else if(importt){importt=false;installPluginShape(PathText.getText());}&#10;            hidePathPane();&#10;        }&#10;&#10;        if(event.getSource()==GroupBtn){&#10;            handleGroup();&#10;        }&#10;        if(event.getSource()==UngroupBtn){&#10;            handleUngroup();&#10;        }&#10;    }&#10;    &#10;    public void showPathPane(){&#10;        Message.setVisible(false);&#10;        PathPane.setVisible(true);&#10;    }&#10;    &#10;    public void hidePathPane(){&#10;        PathPane.setVisible(false);&#10;        Message.setVisible(true);&#10;    }&#10;    &#10;    public void startDrag(MouseEvent event){&#10;        start = new Point2D(event.getX(),event.getY());&#10;        Message.setText(&quot;&quot;);&#10;    }&#10;    public void endDrag(MouseEvent event) throws CloneNotSupportedException{&#10;        end = new Point2D(event.getX(), event.getY());&#10;        if(end.equals(start)){clickFunction();}else{dragFunction();}&#10;    }&#10;    &#10;    public void clickFunction() throws CloneNotSupportedException{&#10;        if(move){move=false;moveFunction();}&#10;        else if(copy){copy=false;copyFunction();}&#10;        else if(resize){resize=false;resizeFunction();}&#10;    }&#10;    &#10;    public void moveFunction(){&#10;        int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;        shapeList.get(index).setTopLeft(start);&#10;        refresh(CanvasBox);&#10;    }&#10;    &#10;    public void copyFunction() throws CloneNotSupportedException{&#10;        int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;        Shape temp = shapeList.get(index).cloneShape();&#10;        if(temp.equals(null)){System.out.println(&quot;Error cloning failed!&quot;);}&#10;        else{&#10;            shapeList.add(temp);&#10;            shapeList.get(shapeList.size()-1).setTopLeft(start);&#10;            refresh(CanvasBox);&#10;        }&#10;    }&#10;    &#10;    public void resizeFunction(){&#10;        int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;        Color c = shapeList.get(index).getFillColor();&#10;        start = shapeList.get(index).getTopLeft();&#10;        //Factory DP&#10;        Shape temp = new ShapeFactory().createShape(shapeList.get(index).getClass().getSimpleName(),start,end,ColorBox.getValue());&#10;        if(temp.getClass().getSimpleName().equals(&quot;Line&quot;)){Message.setText(&quot;Line doesn't support this command. Sorry :(&quot;);return;}&#10;        shapeList.remove(index);&#10;        temp.setFillColor(c);&#10;        shapeList.add(index, temp);&#10;        refresh(CanvasBox);&#10;        &#10;    }&#10;    &#10;    public void dragFunction(){&#10;        String type = ShapeBox.getValue();&#10;        Shape sh;&#10;        //Factory DP&#10;        try{sh = new ShapeFactory().createShape(type,start,end,ColorBox.getValue());}catch(Exception e)&#10;        {Message.setText(&quot;Don't be in a hurry! Choose a shape first :'D&quot;);return;}&#10;        addShape(sh);&#10;        sh.draw(CanvasBox);&#10;        &#10;    }&#10;    &#10;    &#10;    //Observer DP&#10;    public ObservableList&lt;String&gt; getStringList(){&#10;        ObservableList&lt;String&gt; l = FXCollections.observableArrayList();&#10;        try{&#10;            for(Shape s : shapeList){&#10;                String temp = s.getClass().getSimpleName() + &quot;  (&quot; + (int) s.getTopLeft().getX() + &quot;,&quot; + (int) s.getTopLeft().getY() + &quot;)&quot;;&#10;                l.add(temp);&#10;            }&#10;        }catch(Exception e){/* ignore for now */}&#10;        return l;&#10;    }&#10;    &#10;    public ArrayList&lt;Shape&gt; cloneList(ArrayList&lt;Shape&gt; l) throws CloneNotSupportedException{&#10;        ArrayList&lt;Shape&gt; temp = new ArrayList&lt;Shape&gt;();&#10;        for(int i=0;i&lt;l.size();i++){&#10;            temp.add(l.get(i).cloneShape());&#10;        }&#10;        return temp;&#10;    }&#10;    &#10;    &#10;    @Override&#10;    public void initialize(URL url, ResourceBundle rb) {&#10;        ObservableList shapeList = FXCollections.observableArrayList();&#10;        shapeList.add(&quot;Circle&quot;);shapeList.add(&quot;Ellipse&quot;);shapeList.add(&quot;Rectangle&quot;);shapeList.add(&quot;Square&quot;);shapeList.add(&quot;Triangle&quot;);shapeList.add(&quot;Line&quot;);&#10;        ShapeBox.setItems(shapeList);&#10;        &#10;        ColorBox.setValue(Color.BLACK);&#10;    }&#10;&#10;    @Override&#10;    public void refresh(Object canvas) {&#10;        try {&#10;            primary.push(cloneList(shapeList));&#10;        } catch (CloneNotSupportedException ex) {&#10;            Logger.getLogger(FXMLDocumentController.class.getName()).log(Level.SEVERE, null, ex);&#10;        }&#10;        redraw((Canvas) canvas);&#10;        ShapeList.setItems(getStringList());&#10;    }&#10;    &#10;    public void redraw(Canvas canvas){&#10;        GraphicsContext gc = canvas.getGraphicsContext2D();&#10;        gc.clearRect(0, 0, 850, 370);&#10;        try{&#10;        for(int i=0;i&lt;shapeList.size();i++){&#10;            shapeList.get(i).draw(canvas);&#10;        }&#10;        }catch(Exception e){}&#10;    }&#10;&#10;    @Override&#10;    public void addShape(Shape shape) {&#10;        shapeList.add(shape);&#10;        refresh(CanvasBox);&#10;    }&#10;&#10;    @Override&#10;    public void removeShape(Shape shape) {&#10;        shapeList.remove(shape);&#10;        refresh(CanvasBox);&#10;    }&#10;&#10;    @Override&#10;    public void updateShape(Shape oldShape, Shape newShape) {&#10;        shapeList.remove(oldShape);&#10;        shapeList.add(newShape);&#10;        refresh(CanvasBox);&#10;    }&#10;&#10;    @Override&#10;    public Shape[] getShapes() {&#10;        return shapeList.toArray(new Shape[0]);&#10;    }&#10;&#10;    @Override&#10;    public void undo() {&#10;        if(secondary.size()&lt;21){&#10;            ArrayList&lt;Shape&gt; temp = primary.pop();&#10;            secondary.push(temp);&#10;            if(primary.empty()){shapeList = new ArrayList&lt;&gt;();}&#10;            else{shapeList = primary.peek();}&#10;            redraw(CanvasBox);&#10;            ShapeList.setItems(getStringList());&#10;        }else{Message.setText(&quot;Sorry, Cannot do more than 20 Undo's :'(&quot;);}&#10;    }&#10;&#10;    @Override&#10;    public void redo() {&#10;        ArrayList&lt;Shape&gt; temp = secondary.pop();&#10;        primary.push(temp);&#10;        shapeList = primary.peek();&#10;        redraw(CanvasBox);&#10;        ShapeList.setItems(getStringList());&#10;    }&#10;&#10;    @Override&#10;    public void save(String path) {&#10;        if(path.substring(path.length()-4).equals(&quot;.xml&quot;)){&#10;            SaveToXML x = new SaveToXML(path,shapeList);&#10;            if(x.checkSuccess()){Message.setText(&quot;File Saved Successfully&quot;);}&#10;            else{Message.setText(&quot;Error happened while saving, please check the path and try again!&quot;);}&#10;        }&#10;        else if(path.substring(path.length()-5).equals(&quot;.json&quot;)){&#10;            Message.setText(&quot;Sorry, Json is not supported :(&quot;);&#10;        }&#10;        else{Message.setText(&quot;Wrong file format .. save to either .xml or .json&quot;);}&#10;  &#10;    }&#10;&#10;    @Override&#10;    public void load(String path) {&#10;        if(path.substring(path.length()-4).equals(&quot;.xml&quot;)){&#10;            try {&#10;                LoadFromXML l = new LoadFromXML(path);&#10;                if(l.checkSuccess()){&#10;                shapeList = l.getList();&#10;                refresh(CanvasBox);&#10;                Message.setText(&quot;File loaded successfully&quot;);&#10;                }&#10;                else{Message.setText(&quot;Error loading the file .. check the file path and try again!&quot;);}&#10;            } catch (SAXException ex) {&#10;                Logger.getLogger(FXMLDocumentController.class.getName()).log(Level.SEVERE, null, ex);&#10;            } catch (ParserConfigurationException ex) {&#10;                Logger.getLogger(FXMLDocumentController.class.getName()).log(Level.SEVERE, null, ex);&#10;            } catch (IOException ex) {&#10;                Logger.getLogger(FXMLDocumentController.class.getName()).log(Level.SEVERE, null, ex);&#10;            }&#10;            &#10;        }&#10;        else if(path.substring(path.length()-5).equals(&quot;.json&quot;)){&#10;            Message.setText(&quot;Sorry, Json is not supported :(&quot;);&#10;        }&#10;        else{Message.setText(&quot;Wrong file format .. load from either .xml or .json&quot;);}&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Class&lt;? extends Shape&gt;&gt; getSupportedShapes() {&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public void installPluginShape(String jarPath) {&#10;        Message.setText(&quot;Not supported yet.&quot;);&#10;    }&#10;&#10;    private void handleGroup(){&#10;        if(shapeList.size()&lt;2){Message.setText(&quot;Need at least 2 shapes to group.&quot;);return;}&#10;        int idx = ShapeList.getSelectionModel().getSelectedIndex();&#10;        Shape a; Shape b;&#10;        if(idx==-1){&#10;            a = shapeList.get(shapeList.size()-1);&#10;            b = shapeList.get(shapeList.size()-2);&#10;        } else if(idx==shapeList.size()-1){&#10;            a = shapeList.get(idx);&#10;            b = shapeList.get(idx-1);&#10;        } else {&#10;            a = shapeList.get(idx);&#10;            b = shapeList.get(idx+1);&#10;        }&#10;        if(a instanceof GroupShape || b instanceof GroupShape){Message.setText(&quot;Cannot nest groups in this demo.&quot;);return;}&#10;        GroupShape g = new GroupShape(java.util.Arrays.asList(a,b));&#10;        shapeList.remove(a); shapeList.remove(b);&#10;        shapeList.add(g);&#10;        Message.setText(&quot;Composite group created.&quot;);&#10;        refresh(CanvasBox);&#10;    }&#10;&#10;    private void handleUngroup(){&#10;        int idx = ShapeList.getSelectionModel().getSelectedIndex();&#10;        if(idx==-1){Message.setText(&quot;Select a group to ungroup.&quot;);return;}&#10;        Shape target = shapeList.get(idx);&#10;        if(!(target instanceof GroupShape)){Message.setText(&quot;Selected item not a group.&quot;);return;}&#10;        GroupShape g = (GroupShape) target;&#10;        shapeList.remove(g);&#10;        java.util.List&lt;Shape&gt; kids = g.getChildren();&#10;        for(int i=0;i&lt;kids.size();i++){ shapeList.add(idx+i, kids.get(i)); }&#10;        Message.setText(&quot;Group split into children.&quot;);&#10;        refresh(CanvasBox);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package paint.controller;&#10;&#10;&#10;import java.io.IOException;&#10;import java.net.URL;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.ResourceBundle;&#10;import java.util.Stack;&#10;import java.util.logging.Level;&#10;import java.util.logging.Logger;&#10;import javafx.collections.FXCollections;&#10;import javafx.collections.ObservableList;&#10;import javafx.event.ActionEvent;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.Initializable;&#10;import javafx.geometry.Point2D;&#10;import javafx.scene.control.Button;&#10;import javafx.scene.control.ColorPicker;&#10;import javafx.scene.control.ComboBox;&#10;import javafx.scene.layout.GridPane;&#10;import javafx.scene.layout.Pane;&#10;import javafx.scene.canvas.*;&#10;import javafx.scene.control.Label;&#10;import javafx.scene.control.ListView;&#10;import javafx.scene.control.TextField;&#10;import javafx.scene.input.MouseEvent;&#10;import javafx.scene.paint.*;&#10;import javax.xml.parsers.ParserConfigurationException;&#10;import org.xml.sax.SAXException;&#10;import paint.model.*;&#10;&#10;&#10;public class FXMLDocumentController implements Initializable, DrawingEngine {&#10;  &#10;    /***FXML VARIABLES***/&#10;    @FXML&#10;    private Button DeleteBtn;&#10;&#10;    @FXML&#10;    private ComboBox&lt;String&gt; ShapeBox;&#10;&#10;    @FXML&#10;    private Button UndoBtn;&#10;&#10;    @FXML&#10;    private Button RedoBtn;&#10;&#10;    @FXML&#10;    private ColorPicker ColorBox;&#10;&#10;    @FXML&#10;    private Button SaveBtn;&#10;    &#10;    @FXML&#10;    private Button MoveBtn;&#10;    &#10;    @FXML&#10;    private Button RecolorBtn;&#10;    &#10;    @FXML&#10;    private Button LoadBtn;&#10;    &#10;    @FXML&#10;    private GridPane After;&#10;    &#10;    @FXML&#10;    private Pane Before;&#10;    &#10;    @FXML&#10;    private Pane PathPane;&#10;    &#10;    @FXML&#10;    private TextField PathText;&#10;&#10;    @FXML&#10;    private Button StartBtn;&#10;    &#10;    @FXML&#10;    private Button ResizeBtn;&#10;    &#10;    @FXML&#10;    private Button ImportBtn;&#10;    &#10;    @FXML&#10;    private Button PathBtn;&#10;    &#10;    @FXML&#10;    private Canvas CanvasBox;&#10;    &#10;    @FXML&#10;    private Button CopyBtn;&#10;    &#10;    @FXML&#10;    private Button GroupBtn;&#10;&#10;    @FXML&#10;    private Button UngroupBtn;&#10;&#10;    @FXML&#10;    private Label Message;&#10;    &#10;    @FXML&#10;    private ListView ShapeList;&#10;    &#10;    &#10;    &#10;    /***CLASS VARIABLES***/&#10;    private Point2D start;&#10;    private Point2D end;&#10;    &#10;    //SINGLETON DP&#10;    private static ArrayList&lt;Shape&gt; shapeList = new ArrayList&lt;&gt;();&#10;    &#10;    private boolean move=false;&#10;    private boolean copy=false;&#10;    private boolean resize=false;&#10;    private boolean save=false;&#10;    private boolean load=false;&#10;    private boolean importt =false;&#10;    &#10;    //MEMENTO DP&#10;    private Stack&lt;ArrayList&lt;Shape&gt;&gt; primary = new Stack&lt;&gt;();&#10;    private Stack&lt;ArrayList&lt;Shape&gt;&gt; secondary = new Stack&lt;&gt;();&#10;&#10;&#10;    &#10;    @FXML&#10;    private void handleButtonAction(ActionEvent event) {&#10;        if(event.getSource() == StartBtn){&#10;            Before.setVisible(false);&#10;            After.setVisible(true);&#10;        }&#10;        &#10;        Message.setText(&quot;&quot;);&#10;        if(event.getSource()==DeleteBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;            int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;            removeShape(shapeList.get(index));&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to delete it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==RecolorBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;                int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;                shapeList.get(index).setFillColor(ColorBox.getValue());&#10;                refresh(CanvasBox);&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to recolor it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==MoveBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;                move=true;&#10;                Message.setText(&quot;Click on the new top-left position below to move the selected shape.&quot;);&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to move it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==CopyBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;                copy=true;&#10;                Message.setText(&quot;Click on the new top-left position below to copy the selected shape.&quot;);&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to copy it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==ResizeBtn){&#10;            if(!ShapeList.getSelectionModel().isEmpty()){&#10;                resize=true;&#10;                Message.setText(&quot;Click on the new right-button position below to resize the selected shape.&quot;);&#10;            }else{&#10;                Message.setText(&quot;You need to pick a shape first to copy it.&quot;);&#10;            }&#10;        }&#10;        &#10;        if(event.getSource()==UndoBtn){&#10;            if(primary.empty()){Message.setText(&quot;We are back to zero point! .. Can Undo nothing more!&quot;);return;}&#10;            undo();&#10;        }&#10;        &#10;        if(event.getSource()==RedoBtn){&#10;            if(secondary.empty()){Message.setText(&quot;There is no more history for me to get .. Go search history books.&quot;);return;}&#10;            redo();&#10;        }&#10;        &#10;        if(event.getSource()==SaveBtn){&#10;            showPathPane();&#10;            save=true;&#10;        }&#10;        &#10;        if(event.getSource()==LoadBtn){&#10;            showPathPane();&#10;            load=true;&#10;        }&#10;        &#10;        if(event.getSource()==ImportBtn){&#10;            showPathPane();&#10;            importt=true;&#10;        }&#10;        &#10;        if(event.getSource()==PathBtn){&#10;            if(PathText.getText().isEmpty()){PathText.setText(&quot;You need to set the path of the file.&quot;);return;}&#10;            if(save){save=false;save(PathText.getText());}&#10;            else if(load){load=false;load(PathText.getText());}&#10;            else if(importt){importt=false;installPluginShape(PathText.getText());}&#10;            hidePathPane();&#10;        }&#10;&#10;        if(event.getSource()==GroupBtn){&#10;            handleGroup();&#10;        }&#10;        if(event.getSource()==UngroupBtn){&#10;            handleUngroup();&#10;        }&#10;    }&#10;    &#10;    public void showPathPane(){&#10;        Message.setVisible(false);&#10;        PathPane.setVisible(true);&#10;    }&#10;    &#10;    public void hidePathPane(){&#10;        PathPane.setVisible(false);&#10;        Message.setVisible(true);&#10;    }&#10;    &#10;    public void startDrag(MouseEvent event){&#10;        start = new Point2D(event.getX(),event.getY());&#10;        Message.setText(&quot;&quot;);&#10;    }&#10;    public void endDrag(MouseEvent event) throws CloneNotSupportedException{&#10;        end = new Point2D(event.getX(), event.getY());&#10;        if(end.equals(start)){clickFunction();}else{dragFunction();}&#10;    }&#10;    &#10;    public void clickFunction() throws CloneNotSupportedException{&#10;        if(move){move=false;moveFunction();}&#10;        else if(copy){copy=false;copyFunction();}&#10;        else if(resize){resize=false;resizeFunction();}&#10;    }&#10;    &#10;    public void moveFunction(){&#10;        int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;        shapeList.get(index).setTopLeft(start);&#10;        refresh(CanvasBox);&#10;    }&#10;    &#10;    public void copyFunction() throws CloneNotSupportedException{&#10;        int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;        Shape temp = shapeList.get(index).cloneShape();&#10;        if(temp.equals(null)){System.out.println(&quot;Error cloning failed!&quot;);}&#10;        else{&#10;            shapeList.add(temp);&#10;            shapeList.get(shapeList.size()-1).setTopLeft(start);&#10;            refresh(CanvasBox);&#10;        }&#10;    }&#10;    &#10;    public void resizeFunction(){&#10;        int index = ShapeList.getSelectionModel().getSelectedIndex();&#10;        Color c = shapeList.get(index).getFillColor();&#10;        start = shapeList.get(index).getTopLeft();&#10;        //Factory DP&#10;        Shape temp = new ShapeFactory().createShape(shapeList.get(index).getClass().getSimpleName(),start,end,ColorBox.getValue());&#10;        if(temp.getClass().getSimpleName().equals(&quot;Line&quot;)){Message.setText(&quot;Line doesn't support this command. Sorry :(&quot;);return;}&#10;        shapeList.remove(index);&#10;        temp.setFillColor(c);&#10;        shapeList.add(index, temp);&#10;        refresh(CanvasBox);&#10;        &#10;    }&#10;    &#10;    public void dragFunction(){&#10;        String type = ShapeBox.getValue();&#10;        Shape sh;&#10;        //Factory DP&#10;        try{sh = new ShapeFactory().createShape(type,start,end,ColorBox.getValue());}catch(Exception e)&#10;        {Message.setText(&quot;Don't be in a hurry! Choose a shape first :'D&quot;);return;}&#10;        addShape(sh);&#10;        sh.draw(CanvasBox);&#10;        &#10;    }&#10;    &#10;    &#10;    //Observer DP&#10;    public ObservableList&lt;String&gt; getStringList(){&#10;        ObservableList&lt;String&gt; l = FXCollections.observableArrayList();&#10;        try{&#10;            for(Shape s : shapeList){&#10;                String temp = s.getClass().getSimpleName() + &quot;  (&quot; + (int) s.getTopLeft().getX() + &quot;,&quot; + (int) s.getTopLeft().getY() + &quot;)&quot;;&#10;                l.add(temp);&#10;            }&#10;        }catch(Exception e){/* ignore for now */}&#10;        return l;&#10;    }&#10;    &#10;    public ArrayList&lt;Shape&gt; cloneList(ArrayList&lt;Shape&gt; l) throws CloneNotSupportedException{&#10;        ArrayList&lt;Shape&gt; temp = new ArrayList&lt;Shape&gt;();&#10;        for(int i=0;i&lt;l.size();i++){&#10;            temp.add(l.get(i).cloneShape());&#10;        }&#10;        return temp;&#10;    }&#10;    &#10;    &#10;    @Override&#10;    public void initialize(URL url, ResourceBundle rb) {&#10;        ObservableList shapeList = FXCollections.observableArrayList();&#10;        shapeList.add(&quot;Circle&quot;);shapeList.add(&quot;Ellipse&quot;);shapeList.add(&quot;Rectangle&quot;);shapeList.add(&quot;Square&quot;);shapeList.add(&quot;Triangle&quot;);shapeList.add(&quot;Line&quot;);&#10;        ShapeBox.setItems(shapeList);&#10;        &#10;        ColorBox.setValue(Color.BLACK);&#10;        // Refresh highlight on selection change&#10;        if (ShapeList != null &amp;&amp; CanvasBox != null) {&#10;            ShapeList.getSelectionModel().selectedIndexProperty().addListener((obs, oldV, newV) -&gt; {&#10;                redraw(CanvasBox);&#10;            });&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void refresh(Object canvas) {&#10;        try {&#10;            primary.push(cloneList(shapeList));&#10;        } catch (CloneNotSupportedException ex) {&#10;            Logger.getLogger(FXMLDocumentController.class.getName()).log(Level.SEVERE, null, ex);&#10;        }&#10;        redraw((Canvas) canvas);&#10;        ShapeList.setItems(getStringList());&#10;    }&#10;    &#10;    public void redraw(Canvas canvas){&#10;        GraphicsContext gc = canvas.getGraphicsContext2D();&#10;        gc.clearRect(0, 0, 850, 370);&#10;        try{&#10;            int selectedIndex = ShapeList.getSelectionModel() != null ? ShapeList.getSelectionModel().getSelectedIndex() : -1;&#10;            for(int i=0;i&lt;shapeList.size();i++){&#10;                if(i == selectedIndex){&#10;                    paint.model.iShape deco = paint.model.decorator.ShapeDecorator.withSelection(shapeList.get(i));&#10;                    deco.draw(canvas);&#10;                } else {&#10;                    shapeList.get(i).draw(canvas);&#10;                }&#10;            }&#10;        }catch(Exception e){}&#10;    }&#10;&#10;    @Override&#10;    public void addShape(Shape shape) {&#10;        shapeList.add(shape);&#10;        refresh(CanvasBox);&#10;    }&#10;&#10;    @Override&#10;    public void removeShape(Shape shape) {&#10;        shapeList.remove(shape);&#10;        refresh(CanvasBox);&#10;    }&#10;&#10;    @Override&#10;    public void updateShape(Shape oldShape, Shape newShape) {&#10;        shapeList.remove(oldShape);&#10;        shapeList.add(newShape);&#10;        refresh(CanvasBox);&#10;    }&#10;&#10;    @Override&#10;    public Shape[] getShapes() {&#10;        return shapeList.toArray(new Shape[0]);&#10;    }&#10;&#10;    @Override&#10;    public void undo() {&#10;        if(secondary.size()&lt;21){&#10;            ArrayList&lt;Shape&gt; temp = primary.pop();&#10;            secondary.push(temp);&#10;            if(primary.empty()){shapeList = new ArrayList&lt;&gt;();}&#10;            else{shapeList = primary.peek();}&#10;            redraw(CanvasBox);&#10;            ShapeList.setItems(getStringList());&#10;        }else{Message.setText(&quot;Sorry, Cannot do more than 20 Undo's :'(&quot;);}&#10;    }&#10;&#10;    @Override&#10;    public void redo() {&#10;        ArrayList&lt;Shape&gt; temp = secondary.pop();&#10;        primary.push(temp);&#10;        shapeList = primary.peek();&#10;        redraw(CanvasBox);&#10;        ShapeList.setItems(getStringList());&#10;    }&#10;&#10;    @Override&#10;    public void save(String path) {&#10;        if(path.substring(path.length()-4).equals(&quot;.xml&quot;)){&#10;            SaveToXML x = new SaveToXML(path,shapeList);&#10;            if(x.checkSuccess()){Message.setText(&quot;File Saved Successfully&quot;);}&#10;            else{Message.setText(&quot;Error happened while saving, please check the path and try again!&quot;);}&#10;        }&#10;        else if(path.substring(path.length()-5).equals(&quot;.json&quot;)){&#10;            Message.setText(&quot;Sorry, Json is not supported :(&quot;);&#10;        }&#10;        else{Message.setText(&quot;Wrong file format .. save to either .xml or .json&quot;);}&#10;  &#10;    }&#10;&#10;    @Override&#10;    public void load(String path) {&#10;        if(path.substring(path.length()-4).equals(&quot;.xml&quot;)){&#10;            try {&#10;                LoadFromXML l = new LoadFromXML(path);&#10;                if(l.checkSuccess()){&#10;                shapeList = l.getList();&#10;                refresh(CanvasBox);&#10;                Message.setText(&quot;File loaded successfully&quot;);&#10;                }&#10;                else{Message.setText(&quot;Error loading the file .. check the file path and try again!&quot;);}&#10;            } catch (SAXException ex) {&#10;                Logger.getLogger(FXMLDocumentController.class.getName()).log(Level.SEVERE, null, ex);&#10;            } catch (ParserConfigurationException ex) {&#10;                Logger.getLogger(FXMLDocumentController.class.getName()).log(Level.SEVERE, null, ex);&#10;            } catch (IOException ex) {&#10;                Logger.getLogger(FXMLDocumentController.class.getName()).log(Level.SEVERE, null, ex);&#10;            }&#10;            &#10;        }&#10;        else if(path.substring(path.length()-5).equals(&quot;.json&quot;)){&#10;            Message.setText(&quot;Sorry, Json is not supported :(&quot;);&#10;        }&#10;        else{Message.setText(&quot;Wrong file format .. load from either .xml or .json&quot;);}&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Class&lt;? extends Shape&gt;&gt; getSupportedShapes() {&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public void installPluginShape(String jarPath) {&#10;        Message.setText(&quot;Not supported yet.&quot;);&#10;    }&#10;&#10;    private void handleGroup(){&#10;        if(shapeList.size()&lt;2){Message.setText(&quot;Need at least 2 shapes to group.&quot;);return;}&#10;        int idx = ShapeList.getSelectionModel().getSelectedIndex();&#10;        Shape a; Shape b;&#10;        if(idx==-1){&#10;            a = shapeList.get(shapeList.size()-1);&#10;            b = shapeList.get(shapeList.size()-2);&#10;        } else if(idx==shapeList.size()-1){&#10;            a = shapeList.get(idx);&#10;            b = shapeList.get(idx-1);&#10;        } else {&#10;            a = shapeList.get(idx);&#10;            b = shapeList.get(idx+1);&#10;        }&#10;        if(a instanceof GroupShape || b instanceof GroupShape){Message.setText(&quot;Cannot nest groups in this demo.&quot;);return;}&#10;        GroupShape g = new GroupShape(java.util.Arrays.asList(a,b));&#10;        shapeList.remove(a); shapeList.remove(b);&#10;        shapeList.add(g);&#10;        Message.setText(&quot;Composite group created.&quot;);&#10;        refresh(CanvasBox);&#10;    }&#10;&#10;    private void handleUngroup(){&#10;        int idx = ShapeList.getSelectionModel().getSelectedIndex();&#10;        if(idx==-1){Message.setText(&quot;Select a group to ungroup.&quot;);return;}&#10;        Shape target = shapeList.get(idx);&#10;        if(!(target instanceof GroupShape)){Message.setText(&quot;Selected item not a group.&quot;);return;}&#10;        GroupShape g = (GroupShape) target;&#10;        shapeList.remove(g);&#10;        java.util.List&lt;Shape&gt; kids = g.getChildren();&#10;        for(int i=0;i&lt;kids.size();i++){ shapeList.add(idx+i, kids.get(i)); }&#10;        Message.setText(&quot;Group split into children.&quot;);&#10;        refresh(CanvasBox);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Paint/Paint/src/paint/model/decorator/ShapeDecorator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Paint/Paint/src/paint/model/decorator/ShapeDecorator.java" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="package paint.model.decorator;&#10;&#10;import java.util.Map;&#10;import javafx.geometry.Point2D;&#10;import javafx.scene.canvas.Canvas;&#10;import javafx.scene.canvas.GraphicsContext;&#10;import javafx.scene.paint.Color;&#10;import paint.model.Shape;&#10;import paint.model.iShape;&#10;import paint.model.GroupShape;&#10;&#10;/* Base Decorator: delegates everything to the wrapped shape */&#10;public class ShapeDecorator implements iShape {&#10;    protected final Shape delegate;&#10;&#10;    public ShapeDecorator(Shape delegate) {&#10;        this.delegate = delegate;&#10;    }&#10;&#10;    @Override&#10;    public void setPosition(Point2D position) { delegate.setPosition(position); }&#10;&#10;    @Override&#10;    public Point2D getPosition() { return delegate.getPosition(); }&#10;&#10;    @Override&#10;    public void setProperties(Map&lt;String, Double&gt; properties) { delegate.setProperties(properties); }&#10;&#10;    @Override&#10;    public Map&lt;String, Double&gt; getProperties() { return delegate.getProperties(); }&#10;&#10;    @Override&#10;    public void setColor(Color color) { delegate.setColor(color); }&#10;&#10;    @Override&#10;    public Color getColor() { return delegate.getColor(); }&#10;&#10;    @Override&#10;    public void setFillColor(Color color) { delegate.setFillColor(color); }&#10;&#10;    @Override&#10;    public Color getFillColor() { return delegate.getFillColor(); }&#10;&#10;    @Override&#10;    public void draw(Canvas canvas) { delegate.draw(canvas); }&#10;&#10;    @Override&#10;    public Object clone() throws CloneNotSupportedException { return delegate.clone(); }&#10;&#10;    public static iShape withSelection(Shape shape) {&#10;        return new SelectionDecorator(shape);&#10;    }&#10;}&#10;&#10;/* SelectionDecorator: draws a dashed highlight rectangle around the wrapped shape */&#10;class SelectionDecorator extends ShapeDecorator {&#10;    private static final Color HIGHLIGHT = Color.web(&quot;#3fa7ff&quot;, 0.9);&#10;&#10;    public SelectionDecorator(Shape delegate) {&#10;        super(delegate);&#10;    }&#10;&#10;    @Override&#10;    public void draw(Canvas canvas) {&#10;        super.draw(canvas);&#10;        GraphicsContext gc = canvas.getGraphicsContext2D();&#10;        gc.setLineDashes(6, 6);&#10;        gc.setLineWidth(1.5);&#10;        gc.setStroke(HIGHLIGHT);&#10;&#10;        // Base top-left from the shape itself (works for all, including GroupShape)&#10;        Point2D tl = delegate.getTopLeft();&#10;        double w = 0, h = 0;&#10;&#10;        if (delegate instanceof GroupShape) {&#10;            // Compute bounding box across children&#10;            GroupShape g = (GroupShape) delegate;&#10;            double minX = Double.POSITIVE_INFINITY, minY = Double.POSITIVE_INFINITY;&#10;            double maxX = Double.NEGATIVE_INFINITY, maxY = Double.NEGATIVE_INFINITY;&#10;            for (Shape child : g.getChildren()) {&#10;                Map&lt;String, Double&gt; cp = child.getProperties();&#10;                Point2D ctl = child.getTopLeft();&#10;                double cw = 0, ch = 0;&#10;                String ctype = child.getClass().getSimpleName();&#10;                switch (ctype) {&#10;                    case &quot;Rectangle&quot;:&#10;                    case &quot;Square&quot;:&#10;                        cw = cp.getOrDefault(&quot;width&quot;, 0.0);&#10;                        ch = cp.getOrDefault(&quot;height&quot;, 0.0);&#10;                        break;&#10;                    case &quot;Ellipse&quot;:&#10;                    case &quot;Circle&quot;:&#10;                        cw = cp.getOrDefault(&quot;hRadius&quot;, 0.0) * 2;&#10;                        ch = cp.getOrDefault(&quot;vRadius&quot;, 0.0) * 2;&#10;                        break;&#10;                    case &quot;Line&quot;: {&#10;                        double x1 = cp.getOrDefault(&quot;startPositionX&quot;, 0.0);&#10;                        double y1 = cp.getOrDefault(&quot;startPositionY&quot;, 0.0);&#10;                        double x2 = cp.getOrDefault(&quot;endPositionX&quot;, 0.0);&#10;                        double y2 = cp.getOrDefault(&quot;endPositionY&quot;, 0.0);&#10;                        double cminX = Math.min(x1, x2), cminY = Math.min(y1, y2);&#10;                        double cmaxX = Math.max(x1, x2), cmaxY = Math.max(y1, y2);&#10;                        ctl = new Point2D(cminX, cminY);&#10;                        cw = (cmaxX - cminX); ch = (cmaxY - cminY);&#10;                        break;&#10;                    }&#10;                    case &quot;Triangle&quot;: {&#10;                        double tx1 = cp.getOrDefault(&quot;startPositionX&quot;, 0.0);&#10;                        double ty1 = cp.getOrDefault(&quot;startPositionY&quot;, 0.0);&#10;                        double tx2 = cp.getOrDefault(&quot;endPositionX&quot;, 0.0);&#10;                        double ty2 = cp.getOrDefault(&quot;endPositionY&quot;, 0.0);&#10;                        double tx3 = cp.getOrDefault(&quot;thirdPointX&quot;, 0.0);&#10;                        double ty3 = cp.getOrDefault(&quot;thirdPointY&quot;, 0.0);&#10;                        double cminX = Math.min(tx1, Math.min(tx2, tx3));&#10;                        double cminY = Math.min(ty1, Math.min(ty2, ty3));&#10;                        double cmaxX = Math.max(tx1, Math.max(tx2, tx3));&#10;                        double cmaxY = Math.max(ty1, Math.max(ty2, ty3));&#10;                        ctl = new Point2D(cminX, cminY);&#10;                        cw = (cmaxX - cminX); ch = (cmaxY - cminY);&#10;                        break;&#10;                    }&#10;                }&#10;                minX = Math.min(minX, ctl.getX());&#10;                minY = Math.min(minY, ctl.getY());&#10;                maxX = Math.max(maxX, ctl.getX() + cw);&#10;                maxY = Math.max(maxY, ctl.getY() + ch);&#10;            }&#10;            if (minX == Double.POSITIVE_INFINITY) {&#10;                // empty group fallback: nothing to draw&#10;                return;&#10;            }&#10;            tl = new Point2D(minX, minY);&#10;            w = Math.max(0, maxX - minX);&#10;            h = Math.max(0, maxY - minY);&#10;        } else {&#10;            // Non-group shapes: use their properties to find size&#10;            Map&lt;String, Double&gt; p = delegate.getProperties();&#10;            String type = delegate.getClass().getSimpleName();&#10;            switch (type) {&#10;                case &quot;Rectangle&quot;:&#10;                case &quot;Square&quot;:&#10;                    w = p.getOrDefault(&quot;width&quot;, 0.0);&#10;                    h = p.getOrDefault(&quot;height&quot;, 0.0);&#10;                    break;&#10;                case &quot;Ellipse&quot;:&#10;                case &quot;Circle&quot;:&#10;                    w = p.getOrDefault(&quot;hRadius&quot;, 0.0) * 2;&#10;                    h = p.getOrDefault(&quot;vRadius&quot;, 0.0) * 2;&#10;                    break;&#10;                case &quot;Line&quot;: {&#10;                    double x1 = p.getOrDefault(&quot;startPositionX&quot;, 0.0);&#10;                    double y1 = p.getOrDefault(&quot;startPositionY&quot;, 0.0);&#10;                    double x2 = p.getOrDefault(&quot;endPositionX&quot;, 0.0);&#10;                    double y2 = p.getOrDefault(&quot;endPositionY&quot;, 0.0);&#10;                    double minX = Math.min(x1, x2), minY = Math.min(y1, y2);&#10;                    double maxX = Math.max(x1, x2), maxY = Math.max(y1, y2);&#10;                    tl = new Point2D(minX, minY);&#10;                    w = (maxX - minX); h = (maxY - minY);&#10;                    break;&#10;                }&#10;                case &quot;Triangle&quot;: {&#10;                    double tx1 = p.getOrDefault(&quot;startPositionX&quot;, 0.0);&#10;                    double ty1 = p.getOrDefault(&quot;startPositionY&quot;, 0.0);&#10;                    double tx2 = p.getOrDefault(&quot;endPositionX&quot;, 0.0);&#10;                    double ty2 = p.getOrDefault(&quot;endPositionY&quot;, 0.0);&#10;                    double tx3 = p.getOrDefault(&quot;thirdPointX&quot;, 0.0);&#10;                    double ty3 = p.getOrDefault(&quot;thirdPointY&quot;, 0.0);&#10;                    double minX = Math.min(tx1, Math.min(tx2, tx3));&#10;                    double minY = Math.min(ty1, Math.min(ty2, ty3));&#10;                    double maxX = Math.max(tx1, Math.max(tx2, tx3));&#10;                    double maxY = Math.max(ty1, Math.max(ty2, ty3));&#10;                    tl = new Point2D(minX, minY);&#10;                    w = (maxX - minX); h = (maxY - minY);&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        gc.strokeRect(tl.getX() - 3, tl.getY() - 3, w + 6, h + 6);&#10;        gc.setLineDashes(null);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>